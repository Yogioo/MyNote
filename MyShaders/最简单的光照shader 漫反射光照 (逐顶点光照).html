<html>
<head>
  <title>最简单的光照shader 漫反射光照 (逐顶点光照)</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1331"/>
<h1>最简单的光照shader 漫反射光照 (逐顶点光照)</h1>

<div>
<span><div><img src="最简单的光照shader 漫反射光照 (逐顶点光照)_files/TempGIF.gif" type="image/gif" data-filename="TempGIF.gif"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Shader &quot;Unlit/SampleLight&quot;</div><div>{</div><div>Properties</div><div>{</div><div>}</div><div>SubShader</div><div>{</div><div>Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</div><div>LOD 100</div><div><br/></div><div><br/></div><div>Pass</div><div>{</div><div>CGPROGRAM</div><div>#pragma vertex vert</div><div>#pragma fragment frag</div><div><br/></div><div><br/></div><div>#include &quot;UnityCG.cginc&quot;</div><div><br/></div><div><br/></div><div>struct appdata</div><div>{</div><div>float4 vertex : POSITION;</div><div>float3 normal : NORMAL;</div><div>};</div><div><br/></div><div><br/></div><div>struct v2f</div><div>{</div><div>float3 normal : NORMAL;</div><div>float4 vertex : SV_POSITION;</div><div>};</div><div><br/></div><div><br/></div><div>v2f vert (appdata v)</div><div>{</div><div>v2f o;</div><div>o.vertex = UnityObjectToClipPos(v.vertex);</div><div>o.normal = UnityObjectToWorldNormal(v.normal);</div><div>return o;</div><div>}</div><div><br/></div><div><br/></div><div>fixed4 frag (v2f i) : SV_Target</div><div>{</div><div>fixed4 col = saturate(dot(i.normal,_WorldSpaceLightPos0)); //saturate的意思是 把点乘结果限定在0~1之间 点乘物体法线与 物体To世界灯光矢量</div><div>return col;</div><div>}</div><div>ENDCG</div><div>}</div><div>}</div><div>}</div><div><br/></div><div><br/></div></div><div><br/></div><div><img src="最简单的光照shader 漫反射光照 (逐顶点光照)_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Shader &quot;Unlit/SampleLight&quot;</div><div>{</div><div>Properties</div><div>{</div><div>_NormalMap(&quot;NormalMap&quot;,2D) = &quot;White&quot;{}</div><div>}</div><div>SubShader</div><div>{</div><div>Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</div><div>LOD 100</div><div><br/></div><div><br/></div><div>Pass</div><div>{</div><div>CGPROGRAM</div><div>#pragma vertex vert</div><div>#pragma fragment frag</div><div><br/></div><div><br/></div><div>#include &quot;UnityCG.cginc&quot;</div><div><br/></div><div><br/></div><div>struct appdata</div><div>{</div><div>float4 vertex : POSITION;</div><div>float2 uv : TEXCOORD0;</div><div>float3 normal : NORMAL;</div><div>float4 tangent: TANGENT;</div><div>};</div><div><br/></div><div><br/></div><div>struct v2f</div><div>{</div><div>float4 vertex : SV_POSITION;</div><div>float2 uv : TEXCOORD0;</div><div>float3 tangentSpaceLight : TEXCOORD1;</div><div>};</div><div><br/></div><div><br/></div><div>sampler2D _NormalMap;</div><div>float4 _NormalMap_ST;</div><div><br/></div><div><br/></div><div>v2f vert (appdata v)</div><div>{</div><div>v2f o;</div><div>o.vertex = UnityObjectToClipPos(v.vertex);</div><div>o.uv = TRANSFORM_TEX(v.uv,_NormalMap);</div><div><br/></div><div><br/></div><div>float3 normal = UnityObjectToWorldNormal(v.normal); //法线</div><div>float3 tangent = UnityObjectToWorldNormal(v.tangent);//切线</div><div>float3 bitangent = cross(tangent,normal); //副切线</div><div>o.tangentSpaceLight = float3(</div><div>dot(tangent,_WorldSpaceLightPos0),</div><div>dot(bitangent,_WorldSpaceLightPos0),</div><div>dot(normal,_WorldSpaceLightPos0)</div><div>);</div><div><br/></div><div><br/></div><div>return o;</div><div>}</div><div><br/></div><div><br/></div><div>fixed4 frag (v2f i) : SV_Target</div><div>{</div><div>fixed3 tagentNormal = tex2D(_NormalMap,i.uv) * 2 - 1;</div><div>return dot(tagentNormal,i.tangentSpaceLight);</div><div>}</div><div>ENDCG</div><div>}</div><div>}</div><div>}</div><div><br/></div><div><br/></div></div><div><br/></div><div><img src="最简单的光照shader 漫反射光照 (逐顶点光照)_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>逐顶点光照 会出现表面光影不平滑的问题 所以最好用逐像素光照</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'</div><div><br/></div><div><br/></div><div>// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'</div><div><br/></div><div><br/></div><div>Shader &quot;Book/Chapter6/SpecularVertexLevel&quot;</div><div>{</div><div>    Properties</div><div>    {</div><div>        _Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1)</div><div>        _Specular(&quot;Specular&quot;,Color) =(1,1,1,1)</div><div>        _Gloss(&quot;Gloss&quot;,Range(8.0,256)) = 20</div><div>    }</div><div>    SubShader</div><div>    {</div><div>        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</div><div>        LOD 100</div><div><br/></div><div><br/></div><div>        Pass</div><div>        {</div><div>            Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}</div><div>            CGPROGRAM</div><div>            #pragma vertex vert</div><div>            #pragma fragment frag</div><div><br/></div><div><br/></div><div>            #include &quot;UnityCG.cginc&quot;</div><div>            #include &quot;Lighting.cginc&quot;</div><div><br/></div><div><br/></div><div>            struct a2v</div><div>            {</div><div>                float4 vertex : POSITION;</div><div>                float2 normal : NORMAL;</div><div>            };</div><div><br/></div><div><br/></div><div>            struct v2f</div><div>            {</div><div>                float3 color : Color;</div><div>                float4 vertex : SV_POSITION;</div><div>            };</div><div><br/></div><div><br/></div><div>            fixed4 _Diffuse;</div><div>            fixed4 _Specular;</div><div>            float _Gloss;</div><div>    </div><div>            v2f vert (a2v v)</div><div>            {</div><div>                v2f o;</div><div>                o.vertex = UnityObjectToClipPos(v.vertex);</div><div>                //环境光</div><div>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</div><div>                </div><div>                //Transform normal from object to world</div><div>                fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</div><div>                </div><div>                //Get the light direction in world space</div><div>                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</div><div>                </div><div>                //Compute diffuse term</div><div>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir));</div><div>                </div><div>                //Get the reflect direction in world space</div><div>                fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal));</div><div>                </div><div>                //Get the view direction in world space</div><div>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld,v.vertex).xyz);</div><div>                </div><div>                //Compute specular term</div><div>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss);</div><div>                </div><div>                o.color = ambient + diffuse + specular;</div><div>                </div><div>                return o;</div><div>            }</div><div><br/></div><div><br/></div><div>            fixed4 frag (v2f i) : SV_Target</div><div>            {</div><div>                return fixed4(i.color,1);</div><div>            }</div><div>            ENDCG</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div></span>
</div></body></html> 