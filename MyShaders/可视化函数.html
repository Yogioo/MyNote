<html>
<head>
  <title>可视化函数</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="707"/>
<h1>可视化函数</h1>

<div>
<span><div><img src="可视化函数_files/River.gif" type="image/gif" data-filename="River.gif"/></div><div><img src="可视化函数_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="可视化函数_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>多函数相加:</div><div><img src="可视化函数_files/River [1].gif" type="image/gif" data-filename="River.gif"/></div><div><img src="可视化函数_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>复杂函数画面表现</div><div><img src="可视化函数_files/River [2].gif" type="image/gif" data-filename="River.gif"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>using UnityEngine;</div><div><br/></div><div><br/></div><div>public class Graph : MonoBehaviour</div><div>{</div><div>    //方块</div><div>    public Transform pointPrefab;</div><div><br/></div><div><br/></div><div>    //实例出来多少方块</div><div>    [Range(10, 100)] public int resolution = 10;</div><div><br/></div><div><br/></div><div>    //所有方块</div><div>    Transform[] points;</div><div><br/></div><div><br/></div><div>//    [Range(0, 1)] public int function;</div><div>    public GraphFunctionName function;</div><div><br/></div><div><br/></div><div>    void Awake()</div><div>    {</div><div>        float step = 2f / resolution;</div><div>        Vector3 scale = Vector3.one * step;</div><div>        points = new Transform[resolution * resolution];</div><div>        for (int i = 0; i &lt; points.Length; i++)</div><div>        {</div><div>            Transform point = Instantiate(pointPrefab);</div><div>            point.localScale = scale;</div><div>            point.SetParent(transform, false);</div><div>            points[i] = point;</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    GraphFunction[] functions = {SineFunction, Sin2DFunction, MultiSineFunction, MultiSine2DFunction, Ripple, Cylinder,Sphere,Torus};</div><div><br/></div><div><br/></div><div>    private void Update()</div><div>    {</div><div>        float t = Time.time;</div><div>        GraphFunction f = functions[(int) function];</div><div>        float step = 2f / resolution;</div><div>        for (int i = 0, z = 0; z &lt; resolution; z++)</div><div>        {</div><div>            float v = (z + 0.5f) * step - 1f;</div><div>            for (int x = 0; x &lt; resolution; x++, i++)</div><div>            {</div><div>                float u = (x + .5f) * step - 1f;</div><div>                points[i].localPosition = f(u, v, t);</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    private const float pi = Mathf.PI;</div><div><br/></div><div><br/></div><div>    static Vector3 SineFunction(float x, float z, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        p.x = x;</div><div>        p.y = Mathf.Sin(pi * (x + t));</div><div>        p.z = z;</div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 Sin2DFunction(float x, float z, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float y = Mathf.Sin(pi * (x + t));</div><div>        y += Mathf.Sin(pi * (z + t));</div><div>        y *= 0.5f;</div><div><br/></div><div><br/></div><div>        p.y = y;</div><div>        p.x = x;</div><div>        p.z = z;</div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 MultiSineFunction(float x, float z, float t) //多函数</div><div>    {</div><div>        Vector3 p;</div><div>        float y = Mathf.Sin(pi * (x + t));</div><div>        y += Mathf.Sin(pi * 2f * (x + t * 2f)) / 2f;</div><div>        y = y * (2f / 3f);</div><div><br/></div><div><br/></div><div>        p.x = x;</div><div>        p.y = y;</div><div>        p.z = z;</div><div><br/></div><div><br/></div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 MultiSine2DFunction(float x, float z, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float y = 4f * Mathf.Sin(pi * (x + z + t * 0.5f));</div><div>        y += Mathf.Sin(pi * (x + t));</div><div>        y += Mathf.Sin(2f * pi * (z + 2f * t)) * 0.5f;</div><div>        y *= 1f / 5.5f;</div><div><br/></div><div><br/></div><div>        p.x = x;</div><div>        p.y = y;</div><div>        p.z = z;</div><div><br/></div><div><br/></div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 Ripple(float x, float z, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float d = Mathf.Sqrt(x * x + z * z);</div><div>        float y = Mathf.Sin(pi * (4f * d - t));</div><div>        y /= 1f + 10f * d;</div><div><br/></div><div><br/></div><div>        p.x = x;</div><div>        p.y = y;</div><div>        p.z = z;</div><div><br/></div><div><br/></div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 Cylinder(float u, float v, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float r = 0.8f + Mathf.Sin(pi * (6f * u + 2f * v + t)) * 0.2f;</div><div>        p.x = r * Mathf.Sin(pi * u);</div><div>        p.y = v;</div><div>        p.z = r * Mathf.Cos(pi * u);</div><div><br/></div><div><br/></div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 Sphere(float u, float v, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float r = 0.8f + Mathf.Sin(pi * (6f * u + t)) * 0.1f;</div><div>        r += Mathf.Sin(pi * (4f * v + t)) * 0.1f;</div><div>        float s = r * Mathf.Cos(pi * 0.5f * v);</div><div>        p.x = s * Mathf.Sin(pi * u);</div><div>        p.y = r * Mathf.Sin(pi * 0.5f * v);</div><div>        p.z = s * Mathf.Cos(pi * u);</div><div>        return p;</div><div>    }</div><div><br/></div><div><br/></div><div>    static Vector3 Torus(float u, float v, float t)</div><div>    {</div><div>        Vector3 p;</div><div>        float r1 = 0.65f + Mathf.Sin(pi * (6f * u + t)) * 0.1f;</div><div>        float r2 = 0.2f + Mathf.Sin(pi * (4f * v + t)) * 0.05f;</div><div>        float s = r2 * Mathf.Cos(pi * v) + r1;</div><div>        p.x = s * Mathf.Sin(pi * u);</div><div>        p.y = r2 * Mathf.Sin(pi * v);</div><div>        p.z = s * Mathf.Cos(pi * u);</div><div>        return p;</div><div>    }</div><div>    </div><div>}</div><div><br/></div><div>public enum GraphFunctionName</div><div>{</div><div>    Sine,</div><div>    Sin2DFunction,</div><div>    MultiSine,</div><div>    MultiSine2DFunction,</div><div>    Ripple,</div><div>    Cylinder,</div><div>    Sphere,</div><div>    Torus</div><div>}</div><div><br/></div><div>using UnityEngine;</div><div><br/></div><div>public delegate Vector3 GraphFunction (float u, float v, float t);</div></div><div><br/></div></span>
</div></body></html> 